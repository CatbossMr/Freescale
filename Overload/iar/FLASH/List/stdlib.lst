###############################################################################
#
# IAR ANSI C/C++ Compiler V8.20.2.14835/W32 for ARM       17/May/2018  19:45:48
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\workspace\LPLD_OSKinetis_V3\lib\common\stdlib.c
#    Command line =  
#        -f C:\Users\JoyC\AppData\Local\Temp\EW758B.tmp
#        (D:\workspace\LPLD_OSKinetis_V3\lib\common\stdlib.c -D LPLD_K60 -D
#        USE_K60DZ10 -lCN
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List -lB
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List -o
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "D:\Program Files\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\app\ -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\CPU\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\common\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\HW\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\FatFs\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\FatFs\option\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\common\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\driver\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\descriptor\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\class\
#        -Om -I "D:\Program Files\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\" -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List\stdlib.lst
#    Object file  =  
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\Obj\stdlib.o
#
###############################################################################

D:\workspace\LPLD_OSKinetis_V3\lib\common\stdlib.c
      1          /**
      2           * @file stdlib.c
      3           * @version 3.01[By LPLD]
      4           * @date 2013-11-4
      5           * @brief C标准代码库
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 由标准C代码库移植，仅支持ASCII
     10           *
     11           * 版权所有:北京拉普兰德电子技术有限公司
     12           * http://www.lpld.cn
     13           * mail:support@lpld.cn
     14           *
     15           * @par
     16           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     17           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     18           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     19           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     20           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     21           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     22           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     23           */
     24          #include "stdlib.h"
     25          
     26          
     27          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     28          int isspace (int ch)
     29          {
     30              if ((ch == ' ') || (ch == '\t'))    /* \n ??? */
   \                     isspace: (+1)
   \   00000000   0x2820             CMP      R0,#+32
   \   00000002   0xD001             BEQ.N    ??isspace_0
   \   00000004   0x2809             CMP      R0,#+9
   \   00000006   0xD101             BNE.N    ??isspace_1
     31                  return TRUE;
   \                     ??isspace_0: (+1)
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
     32              else
     33                  return FALSE;
   \                     ??isspace_1: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
     34          }
     35          
     36          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     37          int isalnum (int ch)
     38          {
     39              /* ASCII only */
     40              if (((ch >= '0') && (ch <= '9')) ||
     41                  ((ch >= 'A') && (ch <= 'Z')) ||
     42                  ((ch >= 'a') && (ch <= 'z')))
   \                     isalnum: (+1)
   \   00000000   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000004   0x290A             CMP      R1,#+10
   \   00000006   0xD306             BCC.N    ??isalnum_0
   \   00000008   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   0000000C   0x291A             CMP      R1,#+26
   \   0000000E   0xD302             BCC.N    ??isalnum_0
   \   00000010   0x3861             SUBS     R0,R0,#+97
   \   00000012   0x281A             CMP      R0,#+26
   \   00000014   0xD201             BCS.N    ??isalnum_1
     43                  return TRUE;
   \                     ??isalnum_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x4770             BX       LR
     44              else
     45                  return FALSE;
   \                     ??isalnum_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
     46          }
     47          
     48          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     49          int isdigit (int ch)
     50          {
     51              /* ASCII only */
     52              if ((ch >= '0') && (ch <= '9'))
   \                     isdigit: (+1)
   \   00000000   0x3830             SUBS     R0,R0,#+48
   \   00000002   0x280A             CMP      R0,#+10
   \   00000004   0x4180             SBCS     R0,R0,R0
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
     53                  return TRUE;
     54              else
     55                  return FALSE;
   \   00000008   0x4770             BX       LR               ;; return
     56          }
     57          
     58          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     59          int isupper (int ch)
     60          {
     61              /* ASCII only */
     62              if ((ch >= 'A') && (ch <= 'Z'))
   \                     isupper: (+1)
   \   00000000   0x3841             SUBS     R0,R0,#+65
   \   00000002   0x281A             CMP      R0,#+26
   \   00000004   0x4180             SBCS     R0,R0,R0
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
     63                  return TRUE;
     64              else
     65                  return FALSE;
   \   00000008   0x4770             BX       LR               ;; return
     66          }
     67          
     68          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     69          int strcasecmp (const int8 *s1, const int8 *s2)
     70          {
   \                     strcasecmp: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x4604             MOV      R4,R0
     71              int8    c1, c2;
     72              int     result = 0;
   \   00000004   0x2000             MOVS     R0,#+0
     73          
     74              while (result == 0)
   \                     ??strcasecmp_0: (+1)
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD115             BNE.N    ??strcasecmp_1
     75              {
     76                  c1 = *s1++;
   \   0000000A   0xF914 0x3B01      LDRSB    R3,[R4], #+1
     77                  c2 = *s2++;
   \   0000000E   0xF911 0x2B01      LDRSB    R2,[R1], #+1
     78                  if ((c1 >= 'a') && (c1 <= 'z'))
   \   00000012   0xF1A3 0x0061      SUB      R0,R3,#+97
   \   00000016   0x281A             CMP      R0,#+26
   \   00000018   0xD201             BCS.N    ??strcasecmp_2
     79                      c1 = (int8)(c1 - ' ');
   \   0000001A   0x3B20             SUBS     R3,R3,#+32
   \   0000001C   0xB25B             SXTB     R3,R3
     80                  if ((c2 >= 'a') && (c2 <= 'z'))
   \                     ??strcasecmp_2: (+1)
   \   0000001E   0xF1A2 0x0061      SUB      R0,R2,#+97
   \   00000022   0x281A             CMP      R0,#+26
   \   00000024   0xD201             BCS.N    ??strcasecmp_3
     81                      c2 = (int8)(c2 - ' ');
   \   00000026   0x3A20             SUBS     R2,R2,#+32
   \   00000028   0xB252             SXTB     R2,R2
     82                  if ((result = (c1 - c2)) != 0)
   \                     ??strcasecmp_3: (+1)
   \   0000002A   0x1A98             SUBS     R0,R3,R2
   \   0000002C   0xD103             BNE.N    ??strcasecmp_1
     83                      break;
     84                  if ((c1 == 0) || (c2 == 0))
   \   0000002E   0x2B00             CMP      R3,#+0
   \   00000030   0xD001             BEQ.N    ??strcasecmp_1
   \   00000032   0x2A00             CMP      R2,#+0
   \   00000034   0xD1E7             BNE.N    ??strcasecmp_0
     85                      break;
     86              }
     87              return result;
   \                     ??strcasecmp_1: (+1)
   \   00000036   0xBC10             POP      {R4}
   \   00000038   0x4770             BX       LR               ;; return
     88          }
     89          
     90          
     91          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     92          int strncasecmp (const int8 *s1, const int8 *s2, int n)
     93          {
   \                     strncasecmp: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x4605             MOV      R5,R0
     94              int8    c1, c2;
     95              int     k = 0;
   \   00000004   0x2600             MOVS     R6,#+0
     96              int     result = 0;
   \   00000006   0x4630             MOV      R0,R6
     97          
     98              while ( k++ < n )
   \                     ??strncasecmp_0: (+1)
   \   00000008   0x4633             MOV      R3,R6
   \   0000000A   0x1C5E             ADDS     R6,R3,#+1
   \   0000000C   0x4293             CMP      R3,R2
   \   0000000E   0xDA15             BGE.N    ??strncasecmp_1
     99              {
    100                  c1 = *s1++;
   \   00000010   0xF915 0x4B01      LDRSB    R4,[R5], #+1
    101                  c2 = *s2++;
   \   00000014   0xF911 0x3B01      LDRSB    R3,[R1], #+1
    102                  if ((c1 >= 'a') && (c1 <= 'z'))
   \   00000018   0xF1A4 0x0061      SUB      R0,R4,#+97
   \   0000001C   0x281A             CMP      R0,#+26
   \   0000001E   0xD201             BCS.N    ??strncasecmp_2
    103                      c1 = (int8)(c1 - ' ');
   \   00000020   0x3C20             SUBS     R4,R4,#+32
   \   00000022   0xB264             SXTB     R4,R4
    104                  if ((c2 >= 'a') && (c2 <= 'z'))
   \                     ??strncasecmp_2: (+1)
   \   00000024   0xF1A3 0x0061      SUB      R0,R3,#+97
   \   00000028   0x281A             CMP      R0,#+26
   \   0000002A   0xD201             BCS.N    ??strncasecmp_3
    105                      c2 = (int8)(c2 - ' ');
   \   0000002C   0x3B20             SUBS     R3,R3,#+32
   \   0000002E   0xB25B             SXTB     R3,R3
    106                  if ((result = (c1 - c2)) != 0)
   \                     ??strncasecmp_3: (+1)
   \   00000030   0x1AE0             SUBS     R0,R4,R3
   \   00000032   0xD103             BNE.N    ??strncasecmp_1
    107                      break;
    108                  if ((c1 == 0) || (c2 == 0))
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD001             BEQ.N    ??strncasecmp_1
   \   00000038   0x2B00             CMP      R3,#+0
   \   0000003A   0xD1E5             BNE.N    ??strncasecmp_0
    109                      break;
    110              }
    111              return result;
   \                     ??strncasecmp_1: (+1)
   \   0000003C   0xBC70             POP      {R4-R6}
   \   0000003E   0x4770             BX       LR               ;; return
    112          }
    113          
    114          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    115          unsigned long strtoul (int8 *str, int8 **ptr, int base)
    116          {
   \                     strtoul: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
    117              unsigned long rvalue;
    118              int c, err, neg;
    119              int8 *endp;
    120              int8 *startp;
    121          
    122              rvalue = 0;  err = 0;  neg = 0;
   \   0000000A   0xF04F 0x0B00      MOV      R11,#+0
   \   0000000E   0x46D8             MOV      R8,R11
   \   00000010   0x4646             MOV      R6,R8
    123          
    124              /* Check for invalid arguments */
    125              if ((str == NULL) || (base < 0) || (base == 1) || (base > 36))
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD005             BEQ.N    ??strtoul_0
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD403             BMI.N    ??strtoul_0
   \   0000001A   0x2D01             CMP      R5,#+1
   \   0000001C   0xD001             BEQ.N    ??strtoul_0
   \   0000001E   0x2D25             CMP      R5,#+37
   \   00000020   0xDB03             BLT.N    ??strtoul_1
    126              {
    127                  if (ptr != NULL)
   \                     ??strtoul_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD05F             BEQ.N    ??strtoul_2
    128                  {
    129                      *ptr = str;
   \   00000026   0x6027             STR      R7,[R4, #+0]
   \   00000028   0xE05D             B.N      ??strtoul_2
    130                  }
    131                  return 0;
    132              }
    133          
    134              /* Skip leading white spaces */
    135              for (startp = str; isspace(*startp); ++startp)
   \                     ??strtoul_1: (+1)
   \   0000002A   0x46BA             MOV      R10,R7
   \   0000002C   0xE001             B.N      ??strtoul_3
   \                     ??strtoul_4: (+1)
   \   0000002E   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??strtoul_3: (+1)
   \   00000032   0xF99A 0x0000      LDRSB    R0,[R10, #+0]
   \   00000036   0x.... 0x....      BL       isspace
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD1F7             BNE.N    ??strtoul_4
    136                  ;
    137          
    138              /* Check for notations */
    139              switch (startp[0])
   \   0000003E   0xF99A 0x0000      LDRSB    R0,[R10, #+0]
   \   00000042   0x282D             CMP      R0,#+45
   \   00000044   0xD00F             BEQ.N    ??strtoul_5
   \   00000046   0x2830             CMP      R0,#+48
   \   00000048   0xD110             BNE.N    ??strtoul_6
    140              {
    141                  case '0':
    142                      if ((startp[1] == 'x') || (startp[1] == 'X'))
   \   0000004A   0xF99A 0x0001      LDRSB    R0,[R10, #+1]
   \   0000004E   0x2878             CMP      R0,#+120
   \   00000050   0xD001             BEQ.N    ??strtoul_7
   \   00000052   0x2858             CMP      R0,#+88
   \   00000054   0xD10A             BNE.N    ??strtoul_6
    143                      {
    144                          if ((base == 0) || (base == 16))
   \                     ??strtoul_7: (+1)
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD001             BEQ.N    ??strtoul_8
   \   0000005A   0x2D10             CMP      R5,#+16
   \   0000005C   0xD106             BNE.N    ??strtoul_6
    145                          {
    146                              base = 16;
   \                     ??strtoul_8: (+1)
   \   0000005E   0x2510             MOVS     R5,#+16
    147                              startp = &startp[2];
   \   00000060   0xF10A 0x0A02      ADD      R10,R10,#+2
   \   00000064   0xE002             B.N      ??strtoul_6
    148                          }
    149                      }
    150                      break;
    151                  case '-':
    152                      neg = 1;
   \                     ??strtoul_5: (+1)
   \   00000066   0x2601             MOVS     R6,#+1
    153                      startp = &startp[1];
   \   00000068   0xF10A 0x0A01      ADD      R10,R10,#+1
    154                      break;
    155                  default:
    156                      break;
    157              }
    158          
    159              if (base == 0)
   \                     ??strtoul_6: (+1)
   \   0000006C   0x2D00             CMP      R5,#+0
   \   0000006E   0xD100             BNE.N    ??strtoul_9
    160                  base = 10;
   \   00000070   0x250A             MOVS     R5,#+10
    161          
    162              /* Check for invalid chars in str */
    163              for ( endp = startp; (c = *endp) != '\0'; ++endp)
   \                     ??strtoul_9: (+1)
   \   00000072   0x46A9             MOV      R9,R5
   \   00000074   0x4635             MOV      R5,R6
   \   00000076   0xE00E             B.N      ??strtoul_10
    164              {
    165                  /* Check for 0..9,Aa-Zz */
    166                  if (!isalnum(c))
    167                  {
    168                      err = 1;
    169                      break;
    170                  }
    171          
    172                  /* Convert int8 to num in 0..36 */
    173                  if (isdigit(c))
    174                  {
    175                      c = c - '0';
    176                  }
    177                  else
    178                  {
    179                      if (isupper(c))
    180                      {
    181                          c = c - 'A' + 10;
    182                      }
    183                      else
    184                      {
    185                          c = c - 'a' + 10;
    186                      }
    187                  }
    188          
    189                  /* check c against base */
    190                  if (c >= base)
    191                  {
    192                      err = 1;
    193                      break;
    194                  }
    195          
    196                  if (neg)
    197                  {
    198                      rvalue = (rvalue * base) - c;
    199                  }
    200                  else
    201                  {
    202                      rvalue = (rvalue * base) + c;
   \                     ??strtoul_11: (+1)
   \   00000078   0x44B3             ADD      R11,R6,R11
   \   0000007A   0xE00A             B.N      ??strtoul_12
    203                  }
   \                     ??strtoul_13: (+1)
   \   0000007C   0x3E57             SUBS     R6,R6,#+87
   \                     ??strtoul_14: (+1)
   \   0000007E   0x454E             CMP      R6,R9
   \   00000080   0xDA24             BGE.N    ??strtoul_15
   \   00000082   0xFB09 0xFB0B      MUL      R11,R9,R11
   \   00000086   0x4658             MOV      R0,R11
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD0F5             BEQ.N    ??strtoul_11
   \   0000008C   0x46B3             MOV      R11,R6
   \   0000008E   0xEBA0 0x0B0B      SUB      R11,R0,R11
   \                     ??strtoul_12: (+1)
   \   00000092   0xF10A 0x0A01      ADD      R10,R10,#+1
   \                     ??strtoul_10: (+1)
   \   00000096   0xF99A 0x6000      LDRSB    R6,[R10, #+0]
   \   0000009A   0x2E00             CMP      R6,#+0
   \   0000009C   0xD014             BEQ.N    ??strtoul_16
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0x.... 0x....      BL       isalnum
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD011             BEQ.N    ??strtoul_15
   \   000000A8   0x4630             MOV      R0,R6
   \   000000AA   0x.... 0x....      BL       isdigit
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD001             BEQ.N    ??strtoul_17
   \   000000B2   0x3E30             SUBS     R6,R6,#+48
   \   000000B4   0xE7E3             B.N      ??strtoul_14
   \                     ??strtoul_17: (+1)
   \   000000B6   0x4630             MOV      R0,R6
   \   000000B8   0x.... 0x....      BL       isupper
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD0DD             BEQ.N    ??strtoul_13
   \   000000C0   0x3E37             SUBS     R6,R6,#+55
   \   000000C2   0xE7DC             B.N      ??strtoul_14
    204              }
    205          
    206              /* Upon exit, endp points to the character at which valid info */
    207              /* STOPS.  No chars including and beyond endp are used.        */
    208          
    209              if (ptr != NULL)
    210                  *ptr = endp;
    211          
    212              if (err)
    213              {
    214                  if (ptr != NULL)
    215                      *ptr = str;
    216                  
    217                  return 0;
    218              }
    219              else
    220              {
    221                  return rvalue;
   \                     ??strtoul_18: (+1)
   \   000000C4   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    222              }
   \                     ??strtoul_16: (+1)
   \   000000C8   0x4658             MOV      R0,R11
   \   000000CA   0xE002             B.N      ??strtoul_19
   \                     ??strtoul_15: (+1)
   \   000000CC   0x4658             MOV      R0,R11
   \   000000CE   0x2101             MOVS     R1,#+1
   \   000000D0   0x4688             MOV      R8,R1
   \                     ??strtoul_19: (+1)
   \   000000D2   0x2C00             CMP      R4,#+0
   \   000000D4   0xD001             BEQ.N    ??strtoul_20
   \   000000D6   0xF8C4 0xA000      STR      R10,[R4, #+0]
   \                     ??strtoul_20: (+1)
   \   000000DA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000DE   0xD0F1             BEQ.N    ??strtoul_18
   \   000000E0   0x2C00             CMP      R4,#+0
   \   000000E2   0xD000             BEQ.N    ??strtoul_2
   \   000000E4   0x6027             STR      R7,[R4, #+0]
   \                     ??strtoul_2: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \   000000E8   0xE7EC             B.N      ??strtoul_18
    223          }
    224          
    225          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    226          int strlen (const int8 *str)
    227          {
   \                     strlen: (+1)
   \   00000000   0x4601             MOV      R1,R0
    228              int8 *s = (int8 *)str;
    229              int len = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    230          
    231              if (s == NULL)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD101             BNE.N    ??strlen_0
    232                  return 0;
   \   00000008   0x4770             BX       LR
    233          
    234              while (*s++ != '\0')
    235                  ++len;
   \                     ??strlen_1: (+1)
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \                     ??strlen_0: (+1)
   \   0000000C   0xF911 0x2B01      LDRSB    R2,[R1], #+1
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD1FA             BNE.N    ??strlen_1
    236          
    237              return len;
   \   00000014   0x4770             BX       LR               ;; return
    238          }
    239          
    240          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    241          int8 * strcat (int8 *dest, const int8 *src)
    242          {
   \                     strcat: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    243              int8 *dp;
    244              int8 *sp = (int8 *)src;
   \   00000004   0x460D             MOV      R5,R1
    245          
    246              if ((dest != NULL) && (src != NULL))
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD00F             BEQ.N    ??strcat_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD00D             BEQ.N    ??strcat_0
    247              {
    248                  dp = &dest[strlen(dest)];
   \   0000000E   0x.... 0x....      BL       strlen
   \   00000012   0x1821             ADDS     R1,R4,R0
   \   00000014   0xE003             B.N      ??strcat_1
    249          
    250                  while (*sp != '\0')
    251                  {
    252                      *dp++ = *sp++;
   \                     ??strcat_2: (+1)
   \   00000016   0xF815 0x0B01      LDRB     R0,[R5], #+1
   \   0000001A   0xF801 0x0B01      STRB     R0,[R1], #+1
    253                  }
   \                     ??strcat_1: (+1)
   \   0000001E   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F7             BNE.N    ??strcat_2
    254                  *dp = '\0';
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    255              }
    256              return dest;
   \                     ??strcat_0: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    257          }
    258          
    259          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    260          int8 * strncat (int8 *dest, const int8 *src, int n)
    261          {
   \                     strncat: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4615             MOV      R5,R2
    262              int8 *dp;
    263              int8 *sp = (int8 *)src;
   \   00000006   0x460E             MOV      R6,R1
    264          
    265              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD014             BEQ.N    ??strncat_0
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD012             BEQ.N    ??strncat_0
   \   00000010   0x2D01             CMP      R5,#+1
   \   00000012   0xDB10             BLT.N    ??strncat_0
    266              {
    267                  dp = &dest[strlen(dest)];
   \   00000014   0x.... 0x....      BL       strlen
   \   00000018   0x1821             ADDS     R1,R4,R0
    268          
    269                  while ((*sp != '\0') && (n-- > 0))
   \                     ??strncat_1: (+1)
   \   0000001A   0xF996 0x0000      LDRSB    R0,[R6, #+0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD007             BEQ.N    ??strncat_2
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x1E45             SUBS     R5,R0,#+1
   \   00000026   0xDB04             BLT.N    ??strncat_2
    270                  {
    271                      *dp++ = *sp++;
   \   00000028   0xF816 0x0B01      LDRB     R0,[R6], #+1
   \   0000002C   0xF801 0x0B01      STRB     R0,[R1], #+1
   \   00000030   0xE7F3             B.N      ??strncat_1
    272                  }
    273                  *dp = '\0';
   \                     ??strncat_2: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    274              }
    275              return dest;
   \                     ??strncat_0: (+1)
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    276          }
    277          
    278          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    279          int8 * strcpy (int8 *dest, const int8 *src)
    280          {
    281              int8 *dp = (int8 *)dest;
   \                     strcpy: (+1)
   \   00000000   0x4602             MOV      R2,R0
    282              int8 *sp = (int8 *)src;
   \   00000002   0x460B             MOV      R3,R1
    283          
    284              if ((dest != NULL) && (src != NULL))
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD00C             BEQ.N    ??strcpy_0
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD00A             BEQ.N    ??strcpy_0
   \   0000000C   0xE003             B.N      ??strcpy_1
    285              {
    286                  while (*sp != '\0')
    287                  {
    288                      *dp++ = *sp++;
   \                     ??strcpy_2: (+1)
   \   0000000E   0xF813 0x1B01      LDRB     R1,[R3], #+1
   \   00000012   0xF802 0x1B01      STRB     R1,[R2], #+1
    289                  }
   \                     ??strcpy_1: (+1)
   \   00000016   0xF993 0x1000      LDRSB    R1,[R3, #+0]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD1F7             BNE.N    ??strcpy_2
    290                  *dp = '\0';
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x7011             STRB     R1,[R2, #+0]
    291              }
    292              return dest;
   \                     ??strcpy_0: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    293          }
    294          
    295          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    296          int8 * strncpy (int8 *dest, const int8 *src, int n)
    297          {
   \                     strncpy: (+1)
   \   00000000   0xB410             PUSH     {R4}
    298              int8 *dp = (int8 *)dest;
   \   00000002   0x4603             MOV      R3,R0
    299              int8 *sp = (int8 *)src;
   \   00000004   0x460C             MOV      R4,R1
    300          
    301              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD011             BEQ.N    ??strncpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD00F             BEQ.N    ??strncpy_0
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xDB0D             BLT.N    ??strncpy_0
    302              {
    303                  while ((*sp != '\0') && (n-- > 0))
   \                     ??strncpy_1: (+1)
   \   00000012   0xF994 0x1000      LDRSB    R1,[R4, #+0]
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD007             BEQ.N    ??strncpy_2
   \   0000001A   0x4611             MOV      R1,R2
   \   0000001C   0x1E4A             SUBS     R2,R1,#+1
   \   0000001E   0xDB04             BLT.N    ??strncpy_2
    304                  {
    305                      *dp++ = *sp++;
   \   00000020   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \   00000024   0xF803 0x1B01      STRB     R1,[R3], #+1
   \   00000028   0xE7F3             B.N      ??strncpy_1
    306                  }
    307                  *dp = '\0';
   \                     ??strncpy_2: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x7019             STRB     R1,[R3, #+0]
    308              }
    309              return dest;
   \                     ??strncpy_0: (+1)
   \   0000002E   0xBC10             POP      {R4}
   \   00000030   0x4770             BX       LR               ;; return
    310          }
    311          
    312          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    313          int strcmp (const int8 *s1, const int8 *s2)
    314          {
   \                     strcmp: (+1)
   \   00000000   0x4603             MOV      R3,R0
    315              /* No checks for NULL */
    316              int8 *s1p = (int8 *)s1;
    317              int8 *s2p = (int8 *)s2;
    318          
    319              while (*s2p != '\0')
   \                     ??strcmp_0: (+1)
   \   00000002   0xF993 0x0000      LDRSB    R0,[R3, #+0]
   \   00000006   0xF991 0x2000      LDRSB    R2,[R1, #+0]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD004             BEQ.N    ??strcmp_1
    320              {
    321                  if (*s1p != *s2p)
   \   0000000E   0x4290             CMP      R0,R2
   \   00000010   0xD102             BNE.N    ??strcmp_1
    322                      break;
    323          
    324                  ++s1p;
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
    325                  ++s2p;
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0xE7F4             B.N      ??strcmp_0
    326              }
    327              return (*s1p - *s2p);
   \                     ??strcmp_1: (+1)
   \   00000018   0x1A80             SUBS     R0,R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
    328          }
    329          
    330          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    331          int strncmp (const int8 *s1, const int8 *s2, int n)
    332          {
   \                     strncmp: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x4604             MOV      R4,R0
    333              /* No checks for NULL */
    334              int8 *s1p = (int8 *)s1;
    335              int8 *s2p = (int8 *)s2;
    336          
    337              if (n <= 0)
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xDC07             BGT.N    ??strncmp_0
    338                  return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE00C             B.N      ??strncmp_1
    339          
    340              while (*s2p != '\0')
    341              {
    342                  if (*s1p != *s2p)
   \                     ??strncmp_2: (+1)
   \   0000000C   0x4298             CMP      R0,R3
   \   0000000E   0xD109             BNE.N    ??strncmp_3
    343                      break;
    344          
    345                  if (--n == 0)
   \   00000010   0x1E52             SUBS     R2,R2,#+1
   \   00000012   0xD007             BEQ.N    ??strncmp_3
    346                      break;
    347          
    348                  ++s1p;
   \   00000014   0x1C64             ADDS     R4,R4,#+1
    349                  ++s2p;
   \   00000016   0x1C49             ADDS     R1,R1,#+1
    350              }
   \                     ??strncmp_0: (+1)
   \   00000018   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000001C   0xF991 0x3000      LDRSB    R3,[R1, #+0]
   \   00000020   0x2B00             CMP      R3,#+0
   \   00000022   0xD1F3             BNE.N    ??strncmp_2
    351              return (*s1p - *s2p);
   \                     ??strncmp_3: (+1)
   \   00000024   0x1AC0             SUBS     R0,R0,R3
   \                     ??strncmp_1: (+1)
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
    352          }
    353          
    354          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    355          void * memcpy (void *dest, const void *src, unsigned n)
    356          {
   \                     memcpy: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    357              int longs, bytes;
    358              uint32 *dpl = (uint32 *)dest;
   \   00000002   0x4603             MOV      R3,R0
    359              uint32 *spl = (uint32 *)src;
   \   00000004   0x460C             MOV      R4,R1
    360              uint8  *dpb, *spb;
    361          
    362              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD019             BEQ.N    ??memcpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD017             BEQ.N    ??memcpy_0
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD015             BEQ.N    ??memcpy_0
    363              {
    364                  bytes = (n & 0x3);
   \   00000012   0xF002 0x0503      AND      R5,R2,#0x3
    365                  longs = (n - bytes) >> 2;
   \   00000016   0x1B52             SUBS     R2,R2,R5
   \   00000018   0x0892             LSRS     R2,R2,#+2
   \   0000001A   0xE003             B.N      ??memcpy_1
    366              
    367                  while (longs--)
    368                      *dpl++ = *spl++;
   \                     ??memcpy_2: (+1)
   \   0000001C   0xF854 0x1B04      LDR      R1,[R4], #+4
   \   00000020   0xF843 0x1B04      STR      R1,[R3], #+4
   \                     ??memcpy_1: (+1)
   \   00000024   0x4611             MOV      R1,R2
   \   00000026   0x1E4A             SUBS     R2,R1,#+1
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD1F7             BNE.N    ??memcpy_2
    369                  
    370                  dpb = (uint8 *)dpl;
    371                  spb = (uint8 *)spl;
   \   0000002C   0xE003             B.N      ??memcpy_3
    372                  
    373                  while (bytes--)
    374                      *dpb++ = *spb++;
   \                     ??memcpy_4: (+1)
   \   0000002E   0xF814 0x1B01      LDRB     R1,[R4], #+1
   \   00000032   0xF803 0x1B01      STRB     R1,[R3], #+1
   \                     ??memcpy_3: (+1)
   \   00000036   0x4629             MOV      R1,R5
   \   00000038   0x1E4D             SUBS     R5,R1,#+1
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD1F7             BNE.N    ??memcpy_4
    375              }
    376              return dest;
   \                     ??memcpy_0: (+1)
   \   0000003E   0xBC30             POP      {R4,R5}
   \   00000040   0x4770             BX       LR               ;; return
    377          }
    378          
    379          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    380          void * memset (void *s, int c, unsigned n)
    381          {
   \                     memset: (+1)
   \   00000000   0xB410             PUSH     {R4}
    382              /* Not optimized, but very portable */
    383              uint8 *sp = (uint8 *)s;
   \   00000002   0x0004             MOVS     R4,R0
    384          
    385              if ((s != NULL) && (n > 0))
   \   00000004   0xD008             BEQ.N    ??memset_0
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD102             BNE.N    ??memset_1
   \   0000000A   0xE005             B.N      ??memset_0
    386              {
    387                  while (n--)
    388                  {
    389                      *sp++ = (uint8)c;
   \                     ??memset_2: (+1)
   \   0000000C   0xF804 0x1B01      STRB     R1,[R4], #+1
    390                  }
   \                     ??memset_1: (+1)
   \   00000010   0x4613             MOV      R3,R2
   \   00000012   0x1E5A             SUBS     R2,R3,#+1
   \   00000014   0x2B00             CMP      R3,#+0
   \   00000016   0xD1F9             BNE.N    ??memset_2
    391              }
    392              return s;
   \                     ??memset_0: (+1)
   \   00000018   0xBC10             POP      {R4}
   \   0000001A   0x4770             BX       LR               ;; return
    393          }
    394          
    395          /****************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   isalnum
       0   isdigit
       0   isspace
       0   isupper
       8   memcpy
       4   memset
       4   strcasecmp
      16   strcat
        16   -> strlen
       0   strcmp
       0   strcpy
       0   strlen
      12   strncasecmp
      16   strncat
        16   -> strlen
       4   strncmp
       4   strncpy
      40   strtoul
        40   -> isalnum
        40   -> isdigit
        40   -> isspace
        40   -> isupper


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      30  isalnum
      10  isdigit
      16  isspace
      10  isupper
      66  memcpy
      28  memset
      58  strcasecmp
      46  strcat
      28  strcmp
      36  strcpy
      22  strlen
      64  strncasecmp
      58  strncat
      42  strncmp
      50  strncpy
     234  strtoul

 
 798 bytes in section .text
 
 798 bytes of CODE memory

Errors: none
Warnings: none
