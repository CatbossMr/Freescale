###############################################################################
#
# IAR ANSI C/C++ Compiler V8.20.2.14835/W32 for ARM       17/May/2018  19:45:45
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\workspace\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_GPIO.c
#    Command line =  
#        -f C:\Users\JoyC\AppData\Local\Temp\EW6A25.tmp
#        (D:\workspace\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_GPIO.c -D LPLD_K60 -D
#        USE_K60DZ10 -lCN
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List -lB
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List -o
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "D:\Program Files\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\app\ -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\CPU\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\common\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\HW\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\FatFs\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\FatFs\option\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\common\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\driver\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\descriptor\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\class\
#        -Om -I "D:\Program Files\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\" -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List\HW_GPIO.lst
#    Object file  =  
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\Obj\HW_GPIO.o
#
###############################################################################

D:\workspace\LPLD_OSKinetis_V3\lib\LPLD\HW\HW_GPIO.c
      1          /**
      2           * @file HW_GPIO.c
      3           * @version 3.03[By LPLD]
      4           * @date 2014-2-10
      5           * @brief GPIO底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xD408             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000000A   0xFA02 0xF000      LSL      R0,R2,R0
   \   0000000E   0x....             LDR.N    R2,??DataTable9  ;; 0xe000e100
   \   00000010   0x0949             LSRS     R1,R1,#+5
   \   00000012   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn_Type)
   \                     __NVIC_DisableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xD408             BMI.N    ??__NVIC_DisableIRQ_0
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000000A   0xFA02 0xF000      LSL      R0,R2,R0
   \   0000000E   0x....             LDR.N    R2,??DataTable9_1  ;; 0xe000e180
   \   00000010   0x0949             LSRS     R1,R1,#+5
   \   00000012   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
     23          #include "HW_GPIO.h"
     24          
     25          
     26          //@@@@@@@@@@@@@

   \                                 In section .bss, align 4
     27          GPIO_ISR_CALLBACK GPIO_ISR[5];
   \                     GPIO_ISR:
   \   00000000                      DS8 20
     28          
     29          /*
     30           * LPLD_GPIO_Init
     31           * GPIO@@@@@@@
     32           * 
     33           * @@:
     34           *    gpio_init_structure--GPIO@@@@@@@
     35           *                        @@@@@GPIO_InitTypeDef
     36           *
     37           * @@:
     38           *    0--@@@@
     39           *    1--@@@@
     40           */

   \                                 In section .text, align 2, keep-with-next
     41          uint8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
     42          {
   \                     LPLD_GPIO_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB4F0             PUSH     {R4-R7}
     43            uint8 i;
     44            PORT_Type *portx;
     45            uint32 pcr = PORT_PCR_MUX(1)| gpio_init_structure.GPIO_PinControl; 
   \   00000004   0x4610             MOV      R0,R2
   \   00000006   0xF440 0x7080      ORR      R0,R0,#0x100
     46            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   0000000A   0x9B04             LDR      R3,[SP, #+16]
     47            uint32 pins = gpio_init_structure.GPIO_Pins;
     48            uint8 dir = gpio_init_structure.GPIO_Dir;
   \   0000000C   0xF89D 0x501C      LDRB     R5,[SP, #+28]
     49            uint8 output = gpio_init_structure.GPIO_Output;
   \   00000010   0xF89D 0x601D      LDRB     R6,[SP, #+29]
     50            GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
   \   00000014   0x9A08             LDR      R2,[SP, #+32]
     51            
     52            //@@@@
     53            ASSERT( ptx <= PTE);                  //@@@@
     54            ASSERT( dir <= 1 );                   //@@@@
     55            ASSERT( output <= 1 );                //@@@@@@@@
     56            
     57            if(ptx == PTA)
   \   00000016   0x....             LDR.N    R4,??DataTable9_2  ;; 0x400ff000
   \   00000018   0x42A3             CMP      R3,R4
   \   0000001A   0xD10A             BNE.N    ??LPLD_GPIO_Init_0
     58            {
     59              portx = PORTA;  
   \   0000001C   0x....             LDR.N    R7,??DataTable9_3  ;; 0x40049000
     60              i = 0;
   \   0000001E   0x2400             MOVS     R4,#+0
     61            }
     62            else if(ptx == PTB) 
     63            {
     64              portx = PORTB;
     65              i = 1;
     66            }
     67            else if(ptx == PTC) 
     68            {
     69              portx = PORTC;
     70              i = 2;
     71            }
     72            else if(ptx == PTD) 
     73            {
     74              portx = PORTD;
     75              i = 3; 
     76            }
     77            else if(ptx == PTE) 
     78            {
     79              portx = PORTE;
     80              i = 4;
     81            }
     82            else
     83              return 0;
     84            
     85            //@@@@@@@
     86            if(dir==DIR_OUTPUT)
   \                     ??LPLD_GPIO_Init_1: (+1)
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0x695D             LDR      R5,[R3, #+20]
   \   00000024   0xD121             BNE.N    ??LPLD_GPIO_Init_2
     87            {
     88              ptx->PDDR |= pins;
   \   00000026   0x430D             ORRS     R5,R1,R5
   \   00000028   0x615D             STR      R5,[R3, #+20]
     89              //@@@@@@
     90              if(output==OUTPUT_H)
   \   0000002A   0x2E01             CMP      R6,#+1
   \   0000002C   0xD11B             BNE.N    ??LPLD_GPIO_Init_3
     91              {
     92                ptx->PSOR = pins; 
   \   0000002E   0x6059             STR      R1,[R3, #+4]
   \   00000030   0xE01D             B.N      ??LPLD_GPIO_Init_4
     93              }
   \                     ??LPLD_GPIO_Init_0: (+1)
   \   00000032   0x....             LDR.N    R4,??DataTable9_4  ;; 0x400ff040
   \   00000034   0x42A3             CMP      R3,R4
   \   00000036   0xD102             BNE.N    ??LPLD_GPIO_Init_5
   \   00000038   0x....             LDR.N    R7,??DataTable9_5  ;; 0x4004a000
   \   0000003A   0x2401             MOVS     R4,#+1
   \   0000003C   0xE7F0             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_5: (+1)
   \   0000003E   0x....             LDR.N    R4,??DataTable9_6  ;; 0x400ff080
   \   00000040   0x42A3             CMP      R3,R4
   \   00000042   0xD102             BNE.N    ??LPLD_GPIO_Init_6
   \   00000044   0x....             LDR.N    R7,??DataTable9_7  ;; 0x4004b000
   \   00000046   0x2402             MOVS     R4,#+2
   \   00000048   0xE7EA             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_6: (+1)
   \   0000004A   0x....             LDR.N    R4,??DataTable9_8  ;; 0x400ff0c0
   \   0000004C   0x42A3             CMP      R3,R4
   \   0000004E   0xD102             BNE.N    ??LPLD_GPIO_Init_7
   \   00000050   0x....             LDR.N    R7,??DataTable9_9  ;; 0x4004c000
   \   00000052   0x2403             MOVS     R4,#+3
   \   00000054   0xE7E4             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_7: (+1)
   \   00000056   0x....             LDR.N    R4,??DataTable9_10  ;; 0x400ff100
   \   00000058   0x42A3             CMP      R3,R4
   \   0000005A   0xD102             BNE.N    ??LPLD_GPIO_Init_8
   \   0000005C   0x....             LDR.N    R7,??DataTable9_11  ;; 0x4004d000
   \   0000005E   0x2404             MOVS     R4,#+4
   \   00000060   0xE7DE             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_8: (+1)
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE014             B.N      ??LPLD_GPIO_Init_9
     94              else
     95              {
     96                ptx->PCOR = pins;
   \                     ??LPLD_GPIO_Init_3: (+1)
   \   00000066   0x6099             STR      R1,[R3, #+8]
   \   00000068   0xE001             B.N      ??LPLD_GPIO_Init_4
     97              }
     98            }
     99            else
    100            { 
    101              ptx->PDDR &= ~(pins);
   \                     ??LPLD_GPIO_Init_2: (+1)
   \   0000006A   0x438D             BICS     R5,R5,R1
   \   0000006C   0x615D             STR      R5,[R3, #+20]
    102            }
    103            
    104            //@@@@@@@@@@@@
    105            for(uint8 i=0; i<32; i++)
   \                     ??LPLD_GPIO_Init_4: (+1)
   \   0000006E   0x2300             MOVS     R3,#+0
   \   00000070   0xE006             B.N      ??LPLD_GPIO_Init_10
    106            {
    107              if(pins&(1ul<<i))
   \                     ??LPLD_GPIO_Init_11: (+1)
   \   00000072   0x460D             MOV      R5,R1
   \   00000074   0x40DD             LSRS     R5,R5,R3
   \   00000076   0x07ED             LSLS     R5,R5,#+31
   \   00000078   0xD501             BPL.N    ??LPLD_GPIO_Init_12
    108              {
    109                portx->PCR[i] = pcr;
   \   0000007A   0xF847 0x0023      STR      R0,[R7, R3, LSL #+2]
    110              }
    111            }
   \                     ??LPLD_GPIO_Init_12: (+1)
   \   0000007E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??LPLD_GPIO_Init_10: (+1)
   \   00000080   0x2B20             CMP      R3,#+32
   \   00000082   0xDBF6             BLT.N    ??LPLD_GPIO_Init_11
    112          
    113            if(isr_func!=NULL)
   \   00000084   0x0010             MOVS     R0,R2
   \   00000086   0xD002             BEQ.N    ??LPLD_GPIO_Init_13
    114              GPIO_ISR[i] = isr_func;
   \   00000088   0x....             LDR.N    R0,??DataTable9_12
   \   0000008A   0xF840 0x2024      STR      R2,[R0, R4, LSL #+2]
    115            
    116            return 1;
   \                     ??LPLD_GPIO_Init_13: (+1)
   \   0000008E   0x2001             MOVS     R0,#+1
   \                     ??LPLD_GPIO_Init_9: (+1)
   \   00000090   0xBCF0             POP      {R4-R7}
   \   00000092   0xB004             ADD      SP,SP,#+16
   \   00000094   0x4770             BX       LR               ;; return
    117          }
    118          
    119          /*
    120           * LPLD_GPIO_EnableIrq
    121           * @@GPIO@@@@
    122           * 
    123           * @@:
    124           *    gpio_init_structure--GPIO@@@@@@@
    125           *                        @@@@@GPIO_InitTypeDef
    126           *
    127           * @@:
    128           *    0--@@@@
    129           *    1--@@@@
    130           *
    131           */

   \                                 In section .text, align 2, keep-with-next
    132          uint8 LPLD_GPIO_EnableIrq(GPIO_InitTypeDef gpio_init_structure)
    133          {
   \                     LPLD_GPIO_EnableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    134            uint8 i;
    135            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
    136            
    137            //@@@@
    138            ASSERT( ptx <= PTE);                  //@@@@
    139            
    140            if(ptx == PTA)
   \   00000004   0x....             LDR.N    R1,??DataTable9_2  ;; 0x400ff000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_0
    141              i = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE00F             B.N      ??LPLD_GPIO_EnableIrq_1
    142            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_EnableIrq_0: (+1)
   \   0000000E   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ff040
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_2
    143              i = 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE00A             B.N      ??LPLD_GPIO_EnableIrq_1
    144            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_EnableIrq_2: (+1)
   \   00000018   0x....             LDR.N    R1,??DataTable9_6  ;; 0x400ff080
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_3
    145              i = 2;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE005             B.N      ??LPLD_GPIO_EnableIrq_1
    146            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_EnableIrq_3: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable9_8  ;; 0x400ff0c0
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_4
    147              i = 3;
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0xE000             B.N      ??LPLD_GPIO_EnableIrq_1
    148            else
    149              i = 4;
   \                     ??LPLD_GPIO_EnableIrq_4: (+1)
   \   0000002C   0x2004             MOVS     R0,#+4
    150          
    151            enable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_EnableIrq_1: (+1)
   \   0000002E   0x3057             ADDS     R0,R0,#+87
   \   00000030   0xB240             SXTB     R0,R0
   \   00000032   0x.... 0x....      BL       __NVIC_EnableIRQ
    152            
    153            return 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBC02             POP      {R1}
   \   0000003A   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    154          }
    155          
    156          /*
    157           * LPLD_GPIO_DisableIrq
    158           * @@GPIO@@@@
    159           * 
    160           * @@:
    161           *    gpio_init_structure--GPIO@@@@@@@
    162           *                        @@@@@GPIO_InitTypeDef
    163           *
    164           * @@:
    165           *    0--@@@@
    166           *    1--@@@@
    167           *
    168           */

   \                                 In section .text, align 2, keep-with-next
    169          uint8 LPLD_GPIO_DisableIrq(GPIO_InitTypeDef gpio_init_structure)
    170          {
   \                     LPLD_GPIO_DisableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    171            uint8 i;
    172            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
    173            
    174            //@@@@
    175            ASSERT( ptx <= PTE);                  //@@@@
    176            
    177            if(ptx == PTA)
   \   00000004   0x....             LDR.N    R1,??DataTable9_2  ;; 0x400ff000
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_0
    178              i = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE00F             B.N      ??LPLD_GPIO_DisableIrq_1
    179            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_DisableIrq_0: (+1)
   \   0000000E   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ff040
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_2
    180              i = 1;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0xE00A             B.N      ??LPLD_GPIO_DisableIrq_1
    181            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_DisableIrq_2: (+1)
   \   00000018   0x....             LDR.N    R1,??DataTable9_6  ;; 0x400ff080
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_3
    182              i = 2;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0xE005             B.N      ??LPLD_GPIO_DisableIrq_1
    183            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_DisableIrq_3: (+1)
   \   00000022   0x....             LDR.N    R1,??DataTable9_8  ;; 0x400ff0c0
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_4
    184              i = 3;
   \   00000028   0x2003             MOVS     R0,#+3
   \   0000002A   0xE000             B.N      ??LPLD_GPIO_DisableIrq_1
    185            else
    186              i = 4;
   \                     ??LPLD_GPIO_DisableIrq_4: (+1)
   \   0000002C   0x2004             MOVS     R0,#+4
    187            
    188            disable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_DisableIrq_1: (+1)
   \   0000002E   0x3057             ADDS     R0,R0,#+87
   \   00000030   0xB240             SXTB     R0,R0
   \   00000032   0x.... 0x....      BL       __NVIC_DisableIRQ
    189            
    190            return 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBC02             POP      {R1}
   \   0000003A   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    191          }
    192          
    193          /*
    194           * LPLD_GPIO_Ouptut
    195           * @@GPIO@@0~31@@@@
    196           * 
    197           * @@:
    198           *    ptx--@@@
    199           *      |__PTA        --Port A
    200           *      |__PTB        --Port B
    201           *      |__PTC        --Port C
    202           *      |__PTD        --Port D
    203           *      |__PTE        --Port E
    204           *    data32--@@@@
    205           *      |__0x00000000~0xFFFFFFFF--@@@@@GPIO@@@0~31@@@
    206           *
    207           * @@:
    208           *
    209           */

   \                                 In section .text, align 2, keep-with-next
    210          __INLINE void LPLD_GPIO_Output(GPIO_Type *ptx, uint32 data32)
    211          { 
    212            ptx->PDOR = data32;
   \                     LPLD_GPIO_Output: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    213          }
   \   00000002   0x4770             BX       LR               ;; return
    214          
    215          /*
    216           * LPLD_GPIO_Ouptut_b
    217           * @@GPIO@@@@@@@
    218           * 
    219           * @@:
    220           *    ptx--@@@
    221           *      |__PTA        --Port A
    222           *      |__PTB        --Port B
    223           *      |__PTC        --Port C
    224           *      |__PTD        --Port D
    225           *      |__PTE        --Port E
    226           *    lsb_num--@@@@@@@@
    227           *      |__0~31       --GPIO@@@0~31@
    228           *    data1--@@@@
    229           *      |__0          --@@@@@
    230           *      |__1          --@@@@@
    231           *
    232           * @@:
    233           *
    234           */

   \                                 In section .text, align 2, keep-with-next
    235          __INLINE void LPLD_GPIO_Output_b(GPIO_Type *ptx, uint32 lsb_num, uint8 data1)
    236          {
   \                     LPLD_GPIO_Output_b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    237            ptx->PDOR = (ptx->PDOR & ~(0x01L<<lsb_num)) | (uint32)data1<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000000E   0x4319             ORRS     R1,R1,R3
   \   00000010   0x6001             STR      R1,[R0, #+0]
    238          }
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
    239          
    240          /*
    241           * LPLD_GPIO_Ouptut_8b
    242           * @@GPIO@@8@@@@
    243           * 
    244           * @@:
    245           *    ptx--@@@
    246           *      |__PTA        --Port A
    247           *      |__PTB        --Port B
    248           *      |__PTC        --Port C
    249           *      |__PTD        --Port D
    250           *      |__PTE        --Port E
    251           *    lsb_num--@@8@@@@@@@@@@@@
    252           *      |__0~24       --GPIO@@@0~24@
    253           *    data8--@@@@
    254           *      |__0x00~0xFF--@@GPIO@@@@8@@@
    255           *
    256           * @@:
    257           *
    258           */

   \                                 In section .text, align 2, keep-with-next
    259          __INLINE void LPLD_GPIO_Output_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    260          {
   \                     LPLD_GPIO_Output_8b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    261            ptx->PDOR = (ptx->PDOR & ~(0xFFL<<lsb_num)) | (uint32)data8<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x24FF             MOVS     R4,#+255
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000000E   0x4319             ORRS     R1,R1,R3
   \   00000010   0x6001             STR      R1,[R0, #+0]
    262          }
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x4770             BX       LR               ;; return
    263          
    264          /*
    265           * LPLD_GPIO_Toggle
    266           * @@GPIO@@0~31@@@@@
    267           * 
    268           * @@:
    269           *    ptx--@@@
    270           *      |__PTA        --Port A
    271           *      |__PTB        --Port B
    272           *      |__PTC        --Port C
    273           *      |__PTD        --Port D
    274           *      |__PTE        --Port E
    275           *    data32--@@@@
    276           *      |__0x00000000~0xFFFFFFFF--@@@@@GPIO@@@0~31@@@@@1@@@@0@@@@@@
    277           *
    278           * @@:
    279           *
    280           */

   \                                 In section .text, align 2, keep-with-next
    281          __INLINE void LPLD_GPIO_Toggle(GPIO_Type *ptx, uint32 data32)
    282          {  
    283            ptx->PTOR = data32;
   \                     LPLD_GPIO_Toggle: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
    284          }
   \   00000002   0x4770             BX       LR               ;; return
    285          
    286          /*
    287           * LPLD_GPIO_Toggle_b
    288           * @@GPIO@@@@@@@
    289           * 
    290           * @@:
    291           *    ptx--@@@
    292           *      |__PTA        --Port A
    293           *      |__PTB        --Port B
    294           *      |__PTC        --Port C
    295           *      |__PTD        --Port D
    296           *      |__PTE        --Port E
    297           *    lsb_num--@@@@@@@@
    298           *      |__0~31       --GPIO@@@0~31@
    299           *
    300           * @@:
    301           *
    302           */

   \                                 In section .text, align 2, keep-with-next
    303          __INLINE void LPLD_GPIO_Toggle_b(GPIO_Type *ptx, uint8 lsb_num)
    304          {  
    305            ptx->PTOR = 0x01L<<lsb_num;
   \                     LPLD_GPIO_Toggle_b: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    306          }
   \   00000008   0x4770             BX       LR               ;; return
    307          
    308          /*
    309           * LPLD_GPIO_Toggle_8b
    310           * @@GPIO@@8@@@@
    311           * 
    312           * @@:
    313           *    ptx--@@@
    314           *      |__PTA        --Port A
    315           *      |__PTB        --Port B
    316           *      |__PTC        --Port C
    317           *      |__PTD        --Port D
    318           *      |__PTE        --Port E
    319           *    lsb_num--@@8@@@@@@@@@@@@
    320           *      |__0~24       --GPIO@@@0~24@
    321           *    data8--@@@@
    322           *      |__0x00~0xFF--@@GPIO@@@@8@@@
    323           *
    324           * @@:
    325           *
    326           */

   \                                 In section .text, align 2, keep-with-next
    327          __INLINE void LPLD_GPIO_Toggle_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    328          {
    329            ptx->PTOR = (uint32)data8<<lsb_num;
   \                     LPLD_GPIO_Toggle_8b: (+1)
   \   00000000   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000004   0x60C1             STR      R1,[R0, #+12]
    330          }
   \   00000006   0x4770             BX       LR               ;; return
    331          
    332          /*
    333           * LPLD_GPIO_Input
    334           * @@GPIO@0~31@@@@
    335           * 
    336           * @@:
    337           *    ptx--@@@
    338           *      |__PTA        --Port A
    339           *      |__PTB        --Port B
    340           *      |__PTC        --Port C
    341           *      |__PTD        --Port D
    342           *      |__PTE        --Port E
    343           *
    344           * @@:
    345           *    @@GPIO@@32@@@
    346           *
    347           */

   \                                 In section .text, align 2, keep-with-next
    348          __INLINE uint32 LPLD_GPIO_Input(GPIO_Type *ptx)
    349          {
    350            return ptx->PDIR;
   \                     LPLD_GPIO_Input: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    351          }
    352          
    353          /*
    354           * LPLD_GPIO_Input_b
    355           * @@GPIO@@@@@@@
    356           * 
    357           * @@:
    358           *    ptx--@@@
    359           *      |__PTA        --Port A
    360           *      |__PTB        --Port B
    361           *      |__PTC        --Port C
    362           *      |__PTD        --Port D
    363           *      |__PTE        --Port E
    364           *    lsb_num--@@@@@@@@
    365           *      |__0~31       --GPIO@@@0~31@
    366           *
    367           * @@:
    368           *    @@GPIO@@@@@@@@@
    369           *
    370           */

   \                                 In section .text, align 2, keep-with-next
    371          __INLINE uint8 LPLD_GPIO_Input_b(GPIO_Type *ptx, uint8 lsb_num)
    372          {  
    373            return (uint8)((ptx->PDIR>>lsb_num)&0x01L);
   \                     LPLD_GPIO_Input_b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /*
    377           * LPLD_GPIO_Input_8b
    378           * @@GPIO@@8@@@@@@
    379           * 
    380           * @@:
    381           *    ptx--@@@
    382           *      |__PTA        --Port A
    383           *      |__PTB        --Port B
    384           *      |__PTC        --Port C
    385           *      |__PTD        --Port D
    386           *      |__PTE        --Port E
    387           *    lsb_num--@@8@@@@@@@@@@@@
    388           *      |__0~24       --GPIO@@@0~24@
    389           *
    390           * @@:
    391           *    @@GPIO@@8@@@@@@
    392           *
    393           */

   \                                 In section .text, align 2, keep-with-next
    394          __INLINE uint8 LPLD_GPIO_Input_8b(GPIO_Type *ptx, uint8 lsb_num)
    395          {
    396            return (uint8)((ptx->PDIR>>lsb_num)&0xFFL);
   \                     LPLD_GPIO_Input_8b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x4770             BX       LR               ;; return
    397          }
    398          
    399          /*
    400           * PORTA--PORTE@@@@@@
    401           * @@@@@startup_K60.s@@@@@@@@@
    402           * @@@@@@@@@@@@@@@@@@@@@
    403           */

   \                                 In section .text, align 2, keep-with-next
    404          void PORTA_IRQHandler(void)
    405          {
   \                     PORTA_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    406          #if (UCOS_II > 0u)
    407            OS_CPU_SR  cpu_sr = 0u;
    408            OS_ENTER_CRITICAL(); //@@@@@@@@@@@@@@@@@@
    409            OSIntEnter();
    410            OS_EXIT_CRITICAL();
    411          #endif
    412            
    413            //@@@@@@@@@@@
    414            GPIO_ISR[0](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    415            PORTA->ISFR =0xFFFFFFFF;
   \   00000008   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_13  ;; 0x400490a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    416            
    417          #if (UCOS_II > 0u)
    418            OSIntExit();          //@@@@@@@@@@@@@@@@@
    419          #endif
    420          }//           ;87:  PORT A interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    421          

   \                                 In section .text, align 2, keep-with-next
    422          void PORTB_IRQHandler(void)
    423          {
   \                     PORTB_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    424          #if (UCOS_II > 0u)
    425            OS_CPU_SR  cpu_sr = 0u;
    426            OS_ENTER_CRITICAL(); //@@@@@@@@@@@@@@@@@@
    427            OSIntEnter();
    428            OS_EXIT_CRITICAL();
    429          #endif
    430            
    431            //@@@@@@@@@@@
    432            GPIO_ISR[1](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x4780             BLX      R0
    433            PORTB->ISFR =0xFFFFFFFF;
   \   00000008   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_14  ;; 0x4004a0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    434            
    435          #if (UCOS_II > 0u)
    436            OSIntExit();          //@@@@@@@@@@@@@@@@@
    437          #endif
    438          }//           ;88:  PORT B interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    439          

   \                                 In section .text, align 2, keep-with-next
    440          void PORTC_IRQHandler(void)
    441          {
   \                     PORTC_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    442          #if (UCOS_II > 0u)
    443            OS_CPU_SR  cpu_sr = 0u;
    444            OS_ENTER_CRITICAL(); //@@@@@@@@@@@@@@@@@@
    445            OSIntEnter();
    446            OS_EXIT_CRITICAL();
    447          #endif
    448            
    449            //@@@@@@@@@@@
    450            GPIO_ISR[2](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x4780             BLX      R0
    451            PORTC->ISFR =0xFFFFFFFF;
   \   00000008   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_15  ;; 0x4004b0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    452            
    453          #if (UCOS_II > 0u)
    454            OSIntExit();          //@@@@@@@@@@@@@@@@@
    455          #endif
    456          }//           ;89:  PORT C interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    457          

   \                                 In section .text, align 2, keep-with-next
    458          void PORTD_IRQHandler(void)
    459          {
   \                     PORTD_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    460          #if (UCOS_II > 0u)
    461            OS_CPU_SR  cpu_sr = 0u;
    462            OS_ENTER_CRITICAL(); //@@@@@@@@@@@@@@@@@@
    463            OSIntEnter();
    464            OS_EXIT_CRITICAL();
    465          #endif
    466            
    467            //@@@@@@@@@@@
    468            GPIO_ISR[3](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x4780             BLX      R0
    469            PORTD->ISFR =0xFFFFFFFF;
   \   00000008   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_16  ;; 0x4004c0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    470            
    471          #if (UCOS_II > 0u)
    472            OSIntExit();          //@@@@@@@@@@@@@@@@@
    473          #endif
    474          }//           ;90:  PORT D interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    475          

   \                                 In section .text, align 2, keep-with-next
    476          void PORTE_IRQHandler(void)
    477          {
   \                     PORTE_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    478          #if (UCOS_II > 0u)
    479            OS_CPU_SR  cpu_sr = 0u;
    480            OS_ENTER_CRITICAL(); //@@@@@@@@@@@@@@@@@@
    481            OSIntEnter();
    482            OS_EXIT_CRITICAL();
    483          #endif
    484            
    485            //@@@@@@@@@@@
    486            GPIO_ISR[4](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6900             LDR      R0,[R0, #+16]
   \   00000006   0x4780             BLX      R0
    487            PORTE->ISFR =0xFFFFFFFF;
   \   00000008   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_17  ;; 0x4004d0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    488            
    489          #if (UCOS_II > 0u)
    490            OSIntExit();          //@@@@@@@@@@@@@@@@@
    491          #endif
    492          }//           ;91:  PORT E interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     GPIO_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   LPLD_GPIO_DisableIrq
        24   -> __NVIC_DisableIRQ
      24   LPLD_GPIO_EnableIrq
        24   -> __NVIC_EnableIRQ
      32   LPLD_GPIO_Init
       0   LPLD_GPIO_Input
       0   LPLD_GPIO_Input_8b
       0   LPLD_GPIO_Input_b
       0   LPLD_GPIO_Output
       4   LPLD_GPIO_Output_8b
       4   LPLD_GPIO_Output_b
       0   LPLD_GPIO_Toggle
       0   LPLD_GPIO_Toggle_8b
       0   LPLD_GPIO_Toggle_b
       8   PORTA_IRQHandler
         8   -- Indirect call
       8   PORTB_IRQHandler
         8   -- Indirect call
       8   PORTC_IRQHandler
         8   -- Indirect call
       8   PORTD_IRQHandler
         8   -- Indirect call
       8   PORTE_IRQHandler
         8   -- Indirect call
       0   __NVIC_DisableIRQ
       0   __NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      20  GPIO_ISR
      62  LPLD_GPIO_DisableIrq
      62  LPLD_GPIO_EnableIrq
     150  LPLD_GPIO_Init
       4  LPLD_GPIO_Input
       8  LPLD_GPIO_Input_8b
      10  LPLD_GPIO_Input_b
       4  LPLD_GPIO_Output
      22  LPLD_GPIO_Output_8b
      22  LPLD_GPIO_Output_b
       4  LPLD_GPIO_Toggle
       8  LPLD_GPIO_Toggle_8b
      10  LPLD_GPIO_Toggle_b
      18  PORTA_IRQHandler
      18  PORTB_IRQHandler
      18  PORTC_IRQHandler
      18  PORTD_IRQHandler
      18  PORTE_IRQHandler
      24  __NVIC_DisableIRQ
      24  __NVIC_EnableIRQ

 
  20 bytes in section .bss
 576 bytes in section .text
 
 576 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: 1
