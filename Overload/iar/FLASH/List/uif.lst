###############################################################################
#
# IAR ANSI C/C++ Compiler V8.20.2.14835/W32 for ARM       17/May/2018  19:45:48
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\workspace\LPLD_OSKinetis_V3\lib\common\uif.c
#    Command line =  
#        -f C:\Users\JoyC\AppData\Local\Temp\EW7790.tmp
#        (D:\workspace\LPLD_OSKinetis_V3\lib\common\uif.c -D LPLD_K60 -D
#        USE_K60DZ10 -lCN
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List -lB
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List -o
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\Obj
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        "D:\Program Files\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\app\ -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\CPU\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\common\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\HW\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\FatFs\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\FatFs\option\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\common\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\driver\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\descriptor\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\..\..\..\lib\USB\class\
#        -Om -I "D:\Program Files\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\" -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\List\uif.lst
#    Object file  =  
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload3\iar\FLASH\Obj\uif.o
#
###############################################################################

D:\workspace\LPLD_OSKinetis_V3\lib\common\uif.c
      1          /**
      2           * @file uif.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief 提供简单的交互接口
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * The commands, set/show parameters, and prompt are configured 
     10           * at the project level
     11           *
     12           * 版权所有:北京拉普兰德电子技术有限公司
     13           * http://www.lpld.cn
     14           * mail:support@lpld.cn
     15           *
     16           * @par
     17           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     18           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     19           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     20           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     21           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     22           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     23           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     24           */
     25          
     26          #include "common.h"
     27          #include "uif.h"
     28          
     29          /********************************************************************/
     30          /*
     31           * Global messages -- constant strings
     32           */

   \                                 In section .text, align 4, keep-with-next
     33          const int8 HELPMSG[] =
   \                     HELPMSG:
   \   00000000   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     34              "Enter 'help' for help.\n";
     35          

   \                                 In section .text, align 4, keep-with-next
     36          const int8 INVARG[] =
   \                     INVARG:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     37              "Error: Invalid argument: %s\n";
     38          

   \                                 In section .rodata, align 4, keep-with-next
     39          const int8 INVALUE[] = 
   \                     INVALUE:
   \   00000000   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0
     40              "Error: Invalid value: %s\n";
     41          
     42          /*
     43           * Strings used by this file only
     44           */

   \                                 In section .text, align 4, keep-with-next
     45          static const int8 INVCMD[] =
   \                     INVCMD:
   \   00000000   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     46              "Error: No such command: %s\n";
     47          

   \                                 In section .text, align 4, keep-with-next
     48          static const int8 HELPFORMAT[] = 
   \                     HELPFORMAT:
   \   00000000   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
     49              "%8s  %-25s %s %s\n";
     50          

   \                                 In section .text, align 4, keep-with-next
     51          static const int8 SYNTAX[] = 
   \                     SYNTAX:
   \   00000000   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
     52              "Error: Invalid syntax for: %s\n";
     53          

   \                                 In section .text, align 4, keep-with-next
     54          static const int8 INVOPT[] = 
   \                     INVOPT:
   \   00000000   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     55              "Error:  Invalid set/show option: %s\n";
     56          

   \                                 In section .text, align 4, keep-with-next
     57          static const int8 OPTFMT[] = 
   \                     OPTFMT:
   \   00000000   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0
     58              "%12s: ";
     59          

   \                                 In section .bss, align 4
     60          static int8 cmdline1 [UIF_MAX_LINE];
     61          static int8 cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \   00000000                      DS8 80
   \   00000050                      DS8 80
     62          
     63          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          int8 *get_line (int8 *line)
     65          {
   \                     get_line: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     66              int32 pos;
     67              int32 ch;
     68          
     69              pos = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     70              ch = (int32)in_char();
   \   00000006   0x.... 0x....      BL       in_char
     71              while ( (ch != 0x0D /* CR */) &&
     72                      (ch != 0x0A /* LF/NL */) &&
     73                      (pos < UIF_MAX_LINE))
   \                     ??get_line_0: (+1)
   \   0000000A   0x280D             CMP      R0,#+13
   \   0000000C   0xD023             BEQ.N    ??get_line_1
   \   0000000E   0x280A             CMP      R0,#+10
   \   00000010   0xD021             BEQ.N    ??get_line_1
   \   00000012   0x2D50             CMP      R5,#+80
   \   00000014   0xDA1F             BGE.N    ??get_line_1
     74              {
     75                  switch (ch)
   \   00000016   0x4601             MOV      R1,R0
   \   00000018   0x2908             CMP      R1,#+8
   \   0000001A   0xD00D             BEQ.N    ??get_line_2
   \   0000001C   0x297F             CMP      R1,#+127
   \   0000001E   0xD00B             BEQ.N    ??get_line_2
     76                  {
     77                      case 0x08:      /* Backspace */
     78                      case 0x7F:      /* Delete */
     79                          if (pos > 0)
     80                          {
     81                              pos -= 1;
     82                              out_char(0x08);    /* backspace */
     83                              out_char(' ');
     84                              out_char(0x08);    /* backspace */
     85                          }
     86                          break;
     87                      default:
     88                          if ((pos+1) < UIF_MAX_LINE)
   \   00000020   0x1C69             ADDS     R1,R5,#+1
   \   00000022   0x2950             CMP      R1,#+80
   \   00000024   0xDA14             BGE.N    ??get_line_3
     89                          {
     90                              if ((ch > 0x1f) && (ch < 0x80))
   \   00000026   0xF1A0 0x0220      SUB      R2,R0,#+32
   \   0000002A   0x2A60             CMP      R2,#+96
   \   0000002C   0xD210             BCS.N    ??get_line_3
     91                              {
     92                                  line[pos++] = (int8)ch;
   \   0000002E   0x5560             STRB     R0,[R4, R5]
   \   00000030   0x460D             MOV      R5,R1
     93                                  out_char((int8)ch);
   \   00000032   0x.... 0x....      BL       out_char
   \   00000036   0xE00B             B.N      ??get_line_3
     94                              }
     95                          }
   \                     ??get_line_2: (+1)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xDD09             BLE.N    ??get_line_3
   \   0000003C   0x1E6D             SUBS     R5,R5,#+1
   \   0000003E   0x2008             MOVS     R0,#+8
   \   00000040   0x.... 0x....      BL       out_char
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0x.... 0x....      BL       out_char
   \   0000004A   0x2008             MOVS     R0,#+8
   \   0000004C   0x.... 0x....      BL       out_char
     96                          break;
     97                  }
     98                  ch = (int32)in_char();
   \                     ??get_line_3: (+1)
   \   00000050   0x.... 0x....      BL       in_char
   \   00000054   0xE7D9             B.N      ??get_line_0
     99              }
    100              line[pos] = '\0';
   \                     ??get_line_1: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x5560             STRB     R0,[R4, R5]
    101              out_char(0x0D);    /* CR */
   \   0000005A   0x200D             MOVS     R0,#+13
   \   0000005C   0x.... 0x....      BL       out_char
    102              out_char(0x0A);    /* LF */
   \   00000060   0x200A             MOVS     R0,#+10
   \   00000062   0x.... 0x....      BL       out_char
    103          
    104              return line;
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    105          }
    106          
    107          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          int32 make_argv (int8 *cmdline, int8 *argv[])
    109          {
   \                     make_argv: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x4604             MOV      R4,R0
    110              int32 argc, i, in_text;
    111          
    112              /* 
    113               * Break cmdline into strings and argv
    114               * It is permissible for argv to be NULL, in which case
    115               * the purpose of this routine becomes to count args
    116               */
    117              argc = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    118              i = 0;
   \   00000006   0x4605             MOV      R5,R0
    119              in_text = FALSE;
   \   00000008   0x4603             MOV      R3,R0
   \   0000000A   0xE00B             B.N      ??make_argv_0
    120              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
    121              {
    122                  if (((cmdline[i] == ' ')   ||
    123                       (cmdline[i] == '\t')) )
    124                  {
    125                      if (in_text)
    126                      {
    127                          /* end of command line argument */
    128                          cmdline[i] = '\0';
    129                          in_text = FALSE;
    130                      }
    131                      else
    132                      {
    133                          /* still looking for next argument */
    134                          
    135                      }
    136                  }
    137                  else
    138                  {
    139                      /* got non-whitespace character */
    140                      if (in_text)
   \                     ??make_argv_1: (+1)
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD108             BNE.N    ??make_argv_2
    141                      {
    142                      }
    143                      else
    144                      {
    145                          /* start of an argument */
    146                          in_text = TRUE;
   \   00000010   0x2301             MOVS     R3,#+1
    147                          if (argc < UIF_MAX_ARGS)
   \   00000012   0x2809             CMP      R0,#+9
   \   00000014   0xDC13             BGT.N    ??make_argv_3
    148                          {
    149                              if (argv != NULL)
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD002             BEQ.N    ??make_argv_4
    150                                  argv[argc] = &cmdline[i];
   \   0000001A   0x1962             ADDS     R2,R4,R5
   \   0000001C   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    151                              argc++;
   \                     ??make_argv_4: (+1)
   \   00000020   0x1C40             ADDS     R0,R0,#+1
    152                          }
    153                          else
    154                              /*return argc;*/
    155                              break;
    156                      }
    157          
    158                  }
    159                  i++;    /* proceed to next character */
   \                     ??make_argv_2: (+1)
   \   00000022   0x1C6D             ADDS     R5,R5,#+1
   \                     ??make_argv_0: (+1)
   \   00000024   0x5762             LDRSB    R2,[R4, R5]
   \   00000026   0x2A00             CMP      R2,#+0
   \   00000028   0xD009             BEQ.N    ??make_argv_3
   \   0000002A   0x2A20             CMP      R2,#+32
   \   0000002C   0xD001             BEQ.N    ??make_argv_5
   \   0000002E   0x2A09             CMP      R2,#+9
   \   00000030   0xD1EC             BNE.N    ??make_argv_1
   \                     ??make_argv_5: (+1)
   \   00000032   0x2B00             CMP      R3,#+0
   \   00000034   0xD0F5             BEQ.N    ??make_argv_2
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x5562             STRB     R2,[R4, R5]
   \   0000003A   0x4613             MOV      R3,R2
   \   0000003C   0xE7F1             B.N      ??make_argv_2
    160              }
    161              if (argv != NULL)
   \                     ??make_argv_3: (+1)
   \   0000003E   0x2900             CMP      R1,#+0
   \   00000040   0xD002             BEQ.N    ??make_argv_6
    162                  argv[argc] = NULL;
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    163              return argc;
   \                     ??make_argv_6: (+1)
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    164          }
    165          
    166          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    167          void run_cmd (void)
    168          {
   \                     run_cmd: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    169              /*
    170               * Global array of pointers to emulate C argc,argv interface
    171               */
    172              int32 argc;
    173              int8 *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    174          
    175              get_line(cmdline1);
   \   00000004   0x....             LDR.N    R5,??DataTable17_3
   \   00000006   0xF105 0x0050      ADD      R0,R5,#+80
   \   0000000A   0x.... 0x....      BL       get_line
    176          
    177              if (!(argc = make_argv(cmdline1,argv)))
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0xF105 0x0050      ADD      R0,R5,#+80
   \   00000014   0x.... 0x....      BL       make_argv
   \   00000018   0x0004             MOVS     R4,R0
   \   0000001A   0xD10A             BNE.N    ??run_cmd_0
    178              {
    179                  /* no command entered, just a blank line */
    180                  strcpy(cmdline1,cmdline2);
   \   0000001C   0x4629             MOV      R1,R5
   \   0000001E   0xF105 0x0050      ADD      R0,R5,#+80
   \   00000022   0x.... 0x....      BL       strcpy
    181                  argc = make_argv(cmdline1,argv);
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0xF105 0x0050      ADD      R0,R5,#+80
   \   0000002C   0x.... 0x....      BL       make_argv
   \   00000030   0x4604             MOV      R4,R0
    182              }
    183              cmdline2[0] = '\0';
   \                     ??run_cmd_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7028             STRB     R0,[R5, #+0]
    184          
    185              if (argc)
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD033             BEQ.N    ??run_cmd_1
    186              {
    187                  int32 i;
    188                  for (i = 0; i < UIF_NUM_CMD; i++)
   \   0000003A   0x4606             MOV      R6,R0
   \   0000003C   0xE000             B.N      ??run_cmd_2
   \                     ??run_cmd_3: (+1)
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \                     ??run_cmd_2: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable17_4
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x4286             CMP      R6,R0
   \   00000046   0xDA23             BGE.N    ??run_cmd_4
    189                  {
    190                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \   00000048   0x....             LDR.N    R0,??DataTable17_5
   \   0000004A   0xEBC6 0x01C6      RSB      R1,R6,R6, LSL #+3
   \   0000004E   0xEB10 0x0781      ADDS     R7,R0,R1, LSL #+2
   \   00000052   0x9900             LDR      R1,[SP, #+0]
   \   00000054   0x6838             LDR      R0,[R7, #+0]
   \   00000056   0x.... 0x....      BL       strcasecmp
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD1EF             BNE.N    ??run_cmd_3
    191                      {
    192                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    193                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \   0000005E   0x1E60             SUBS     R0,R4,#+1
   \   00000060   0x6879             LDR      R1,[R7, #+4]
   \   00000062   0x4288             CMP      R0,R1
   \   00000064   0xDB0E             BLT.N    ??run_cmd_5
   \   00000066   0x68B9             LDR      R1,[R7, #+8]
   \   00000068   0x4281             CMP      R1,R0
   \   0000006A   0xDB0B             BLT.N    ??run_cmd_5
    194                          {
    195                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \   0000006C   0x7B38             LDRB     R0,[R7, #+12]
   \   0000006E   0x07C0             LSLS     R0,R0,#+31
   \   00000070   0xD503             BPL.N    ??run_cmd_6
    196                              {
    197                                  strcpy(cmdline2,argv[0]);
   \   00000072   0x9900             LDR      R1,[SP, #+0]
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       strcpy
    198                              }
    199                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6: (+1)
   \   0000007A   0x4669             MOV      R1,SP
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x693A             LDR      R2,[R7, #+16]
   \   00000080   0x4790             BLX      R2
    200                              return;
   \   00000082   0xE00E             B.N      ??run_cmd_1
    201                          }
    202                          else
    203                          {
    204                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5: (+1)
   \   00000084   0x9900             LDR      R1,[SP, #+0]
   \   00000086   0x.... 0x....      ADR.W    R0,SYNTAX
   \   0000008A   0x.... 0x....      BL       printf
    205                              return;
   \   0000008E   0xE008             B.N      ??run_cmd_1
    206                          }
    207                      }
    208                  }
    209                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_4: (+1)
   \   00000090   0x9900             LDR      R1,[SP, #+0]
   \   00000092   0x.... 0x....      ADR.W    R0,INVCMD
   \   00000096   0x.... 0x....      BL       printf
    210                  printf(HELPMSG);
   \   0000009A   0x.... 0x....      ADR.W    R0,HELPMSG
   \   0000009E   0x.... 0x....      BL       printf
    211              }
    212          }
   \                     ??run_cmd_1: (+1)
   \   000000A2   0xB00B             ADD      SP,SP,#+44
   \   000000A4   0xBDF0             POP      {R4-R7,PC}       ;; return
    213          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    214          uint32 get_value (int8 *s, int32 *success, int32 base)
    215          {
   \                     get_value: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    216              uint32 value;
    217              int8 *p;
    218          
    219              value = strtoul(s,&p,base);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x.... 0x....      BL       strtoul
    220              if ((value == 0) && (p == s))
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD105             BNE.N    ??get_value_0
   \   00000010   0x9900             LDR      R1,[SP, #+0]
   \   00000012   0x42A1             CMP      R1,R4
   \   00000014   0xD102             BNE.N    ??get_value_0
    221              {
    222                  *success = FALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6028             STR      R0,[R5, #+0]
    223                  return 0;
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}
    224              }
    225              else
    226              {
    227                  *success = TRUE;
   \                     ??get_value_0: (+1)
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x6029             STR      R1,[R5, #+0]
    228                  return value;
   \   00000020   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    229              }
    230          }
    231          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    232          void uif_cmd_help (int32 argc, int8 **argv)
    233          {
   \                     uif_cmd_help: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    234              int32 index;
    235              
    236              (void)argc;
    237              (void)argv;
    238              
    239              printf("\n");
   \   00000002   0x....             ADR.N    R4,??DataTable17  ;; "\n"
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       printf
    240              for (index = 0; index < UIF_NUM_CMD; index++)
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0xE00E             B.N      ??uif_cmd_help_0
    241              {
    242                  printf(HELPFORMAT,
    243                      UIF_CMDTAB[index].cmd,
    244                      UIF_CMDTAB[index].description,
    245                      UIF_CMDTAB[index].cmd,
    246                      UIF_CMDTAB[index].syntax);
   \                     ??uif_cmd_help_1: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable17_5
   \   00000010   0xEBC5 0x01C5      RSB      R1,R5,R5, LSL #+3
   \   00000014   0xEB00 0x0081      ADD      R0,R0,R1, LSL #+2
   \   00000018   0x6981             LDR      R1,[R0, #+24]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
   \   0000001C   0x6803             LDR      R3,[R0, #+0]
   \   0000001E   0x6942             LDR      R2,[R0, #+20]
   \   00000020   0x4619             MOV      R1,R3
   \   00000022   0x.... 0x....      ADR.W    R0,HELPFORMAT
   \   00000026   0x.... 0x....      BL       printf
    247              }
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_help_0: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable17_4
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x4285             CMP      R5,R0
   \   00000032   0xDBEC             BLT.N    ??uif_cmd_help_1
    248              printf("\n");
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000003A   0x.... 0x....      B.W      printf
    249          }
    250          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    251          void uif_cmd_set (int32 argc, int8 **argv)
    252          {
   \                     uif_cmd_set: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460D             MOV      R5,R1
    253              int32 index;
    254          
    255              printf("\n");
   \   00000006   0x....             ADR.N    R4,??DataTable17  ;; "\n"
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       printf
    256              if (argc == 1)
   \   0000000E   0x2E01             CMP      R6,#+1
   \   00000010   0xD11D             BNE.N    ??uif_cmd_set_0
    257              {
    258                  printf("Valid 'set' options:\n");
   \   00000012   0x.... 0x....      ADR.W    R0,?_1
   \   00000016   0x.... 0x....      BL       printf
    259                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0x....             LDR.N    R6,??DataTable17_6
   \   0000001E   0xE00D             B.N      ??uif_cmd_set_1
    260                  {
    261                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_set_2: (+1)
   \   00000020   0xEB05 0x0085      ADD      R0,R5,R5, LSL #+2
   \   00000024   0x0087             LSLS     R7,R0,#+2
   \   00000026   0x59F1             LDR      R1,[R6, R7]
   \   00000028   0x.... 0x....      ADR.W    R0,OPTFMT
   \   0000002C   0x.... 0x....      BL       printf
    262                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \   00000030   0x19F0             ADDS     R0,R6,R7
   \   00000032   0x6901             LDR      R1,[R0, #+16]
   \   00000034   0x....             ADR.N    R0,??DataTable17_1  ;; "%s\n"
   \   00000036   0x.... 0x....      BL       printf
    263                  }
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_set_1: (+1)
   \   0000003C   0x....             LDR.N    R0,??DataTable17_7
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xDBED             BLT.N    ??uif_cmd_set_2
    264                  printf("\n");
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000004A   0x.... 0x....      B.W      printf
    265                  return;
    266              }
    267          
    268              if (argc != 3)
   \                     ??uif_cmd_set_0: (+1)
   \   0000004E   0x2E03             CMP      R6,#+3
   \   00000050   0xD005             BEQ.N    ??uif_cmd_set_3
    269              {
    270                  printf("Error: Invalid argument list\n");
   \   00000052   0x.... 0x....      ADR.W    R0,?_3
   \   00000056   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   0000005A   0x.... 0x....      B.W      printf
    271                  return;
    272              }
    273          
    274              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_3: (+1)
   \   0000005E   0x2400             MOVS     R4,#+0
   \   00000060   0xE000             B.N      ??uif_cmd_set_4
   \                     ??uif_cmd_set_5: (+1)
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_4: (+1)
   \   00000064   0x6869             LDR      R1,[R5, #+4]
   \   00000066   0x....             LDR.N    R0,??DataTable17_7
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xDA1C             BGE.N    ??uif_cmd_set_6
    275              {
    276                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   0000006E   0x....             LDR.N    R0,??DataTable17_6
   \   00000070   0xEB04 0x0284      ADD      R2,R4,R4, LSL #+2
   \   00000074   0xEB10 0x0682      ADDS     R6,R0,R2, LSL #+2
   \   00000078   0x6830             LDR      R0,[R6, #+0]
   \   0000007A   0x.... 0x....      BL       strcasecmp
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD1EF             BNE.N    ??uif_cmd_set_5
    277                  {
    278                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    279                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000082   0x6870             LDR      R0,[R6, #+4]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xDC08             BGT.N    ??uif_cmd_set_7
   \   00000088   0x68B0             LDR      R0,[R6, #+8]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xDD05             BLE.N    ??uif_cmd_set_7
    280                      {
    281                          UIF_SETCMDTAB[index].func(argc,argv);
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0x2003             MOVS     R0,#+3
   \   00000092   0x68F2             LDR      R2,[R6, #+12]
   \   00000094   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   00000098   0x4710             BX       R2
    282                          return;
    283                      }
    284                      else
    285                      {
    286                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_7: (+1)
   \   0000009A   0x6869             LDR      R1,[R5, #+4]
   \   0000009C   0x.... 0x....      ADR.W    R0,INVARG
   \   000000A0   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000000A4   0x.... 0x....      B.W      printf
    287                          return;
    288                      }
    289                  }
    290              }
    291              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_6: (+1)
   \   000000A8   0x.... 0x....      ADR.W    R0,INVOPT
   \   000000AC   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   000000B0   0x.... 0x....      B.W      printf
    292          }
    293          
    294          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          void uif_cmd_show (int32 argc, int8 **argv)
    296          {
   \                     uif_cmd_show: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460D             MOV      R5,R1
    297              int32 index;
    298          
    299              printf("\n");
   \   00000008   0x....             ADR.N    R7,??DataTable17  ;; "\n"
   \   0000000A   0x4638             MOV      R0,R7
   \   0000000C   0x.... 0x....      BL       printf
    300              if (argc == 1)
   \   00000010   0x....             LDR.N    R0,??DataTable17_7
   \   00000012   0x6804             LDR      R4,[R0, #+0]
   \   00000014   0x2E01             CMP      R6,#+1
   \   00000016   0xD121             BNE.N    ??uif_cmd_show_0
    301              {
    302                  /*
    303                   * Show all Option settings
    304                   */
    305                  argc = 2;
    306                  argv[2] = NULL;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x60A8             STR      R0,[R5, #+8]
    307                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \   0000001C   0x4606             MOV      R6,R0
   \   0000001E   0x.... 0x....      LDR.W    R8,??DataTable17_6
   \   00000022   0xE014             B.N      ??uif_cmd_show_1
    308                  {
    309                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_show_2: (+1)
   \   00000024   0xEB06 0x0086      ADD      R0,R6,R6, LSL #+2
   \   00000028   0xEA4F 0x0980      LSL      R9,R0,#+2
   \   0000002C   0xF858 0x1009      LDR      R1,[R8, R9]
   \   00000030   0x.... 0x....      ADR.W    R0,OPTFMT
   \   00000034   0x.... 0x....      BL       printf
    310                      UIF_SETCMDTAB[index].func(argc,argv);
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xF108 0x020C      ADD      R2,R8,#+12
   \   00000040   0xF852 0x2009      LDR      R2,[R2, R9]
   \   00000044   0x4790             BLX      R2
    311                      printf("\n");
   \   00000046   0x4638             MOV      R0,R7
   \   00000048   0x.... 0x....      BL       printf
    312                  }
   \   0000004C   0x1C76             ADDS     R6,R6,#+1
   \                     ??uif_cmd_show_1: (+1)
   \   0000004E   0x42A6             CMP      R6,R4
   \   00000050   0xDBE8             BLT.N    ??uif_cmd_show_2
    313                  printf("\n");
   \   00000052   0x4638             MOV      R0,R7
   \   00000054   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000058   0x.... 0x....      B.W      printf
    314                  return;
    315              }
    316          
    317              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0: (+1)
   \   0000005C   0x2700             MOVS     R7,#+0
   \   0000005E   0xE000             B.N      ??uif_cmd_show_3
   \                     ??uif_cmd_show_4: (+1)
   \   00000060   0x1C7F             ADDS     R7,R7,#+1
   \                     ??uif_cmd_show_3: (+1)
   \   00000062   0x6869             LDR      R1,[R5, #+4]
   \   00000064   0x42A7             CMP      R7,R4
   \   00000066   0xDA2A             BGE.N    ??uif_cmd_show_5
    318              {
    319                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000068   0x....             LDR.N    R0,??DataTable17_6
   \   0000006A   0xEB07 0x0287      ADD      R2,R7,R7, LSL #+2
   \   0000006E   0xEB00 0x0882      ADD      R8,R0,R2, LSL #+2
   \   00000072   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000076   0x.... 0x....      BL       strcasecmp
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD1F0             BNE.N    ??uif_cmd_show_4
    320                  {
    321                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    322                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   0000007E   0x1EB0             SUBS     R0,R6,#+2
   \   00000080   0xF8D8 0x1004      LDR      R1,[R8, #+4]
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xDB13             BLT.N    ??uif_cmd_show_6
   \   00000088   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \   0000008C   0x4281             CMP      R1,R0
   \   0000008E   0xDB0F             BLT.N    ??uif_cmd_show_6
    323                      {
    324                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   00000090   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   00000094   0x.... 0x....      ADR.W    R0,OPTFMT
   \   00000098   0x.... 0x....      BL       printf
    325                          UIF_SETCMDTAB[index].func(argc,argv);
   \   0000009C   0x4629             MOV      R1,R5
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0xF8D8 0x200C      LDR      R2,[R8, #+12]
   \   000000A4   0x4790             BLX      R2
    326                          printf("\n\n");
   \   000000A6   0x....             ADR.N    R0,??DataTable17_2  ;; 0x0A, 0x0A, 0x00, 0x00
   \   000000A8   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   000000AC   0x.... 0x....      B.W      printf
    327                          return;
    328                      }
    329                      else
    330                      {
    331                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_6: (+1)
   \   000000B0   0x6869             LDR      R1,[R5, #+4]
   \   000000B2   0x.... 0x....      ADR.W    R0,INVARG
   \   000000B6   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000BA   0x.... 0x....      B.W      printf
    332                          return;
    333                      }
    334                  }
    335              }
    336              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_5: (+1)
   \   000000BE   0x.... 0x....      ADR.W    R0,INVOPT
   \   000000C2   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000C6   0x.... 0x....      B.W      printf
    337          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_0:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    338          
    339          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   get_line
        16   -> in_char
        16   -> out_char
      16   get_value
        16   -> strtoul
       8   make_argv
      64   run_cmd
        64   -- Indirect call
        64   -> get_line
        64   -> make_argv
        64   -> printf
        64   -> strcasecmp
        64   -> strcpy
      16   uif_cmd_help
         0   -> printf
        16   -> printf
      24   uif_cmd_set
         0   -- Indirect call
         0   -> printf
        24   -> printf
        24   -> strcasecmp
      32   uif_cmd_show
        32   -- Indirect call
         0   -> printf
        32   -> printf
        32   -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       2  ?_0
      24  ?_1
       4  ?_2
      32  ?_3
       4  ?_4
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
     160  cmdline2
          cmdline1
     106  get_line
      34  get_value
      76  make_argv
     166  run_cmd
      62  uif_cmd_help
     180  uif_cmd_set
     202  uif_cmd_show

 
   160 bytes in section .bss
    38 bytes in section .rodata
 1 098 bytes in section .text
 
 1 098 bytes of CODE  memory
    38 bytes of CONST memory
   160 bytes of DATA  memory

Errors: none
Warnings: none
